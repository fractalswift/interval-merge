# Test cases:

example_intervals = [(1, 3), (5, 12), (4, 10), (20, 25)]

more_intervals = [(1, 3), (5, 12), (4, 10), (20, 25), (27, 29), (19, 23)]

intervals_with_copies = [(1, 3), (1, 3), (5, 12),
                         (4, 10), (20, 25), (27, 29), (19, 23)]

intervals_with_multiple_overlaps = [
    (1, 3), (5, 12), (4, 10), (20, 25), (27, 29), (19, 23), (20, 21)]

all_cases_at_once = [(3, 2), (1, 4), (5,5), (7, 6), (5, 12), (1, 3),
                     (5, 12), (4, 10), (20, 25), (27, 29), (19, 23), (20, 21)]


# This function accepts a sorted intverals
# list and checks to see if any of the intervals
# overlap


def check_for_overlaps(intervals_list):

    # This list will store the indices of any
    # positions that overlaps with the one before it
    overlap_positions = []

    # Counter will increment as a way to get list index
    counter = 0

    # Current interval will be compared with
    # previous interval. This is value for the first one.
    prev_i = (0, 0)

    for i in intervals_list:

        # Check if lower bound of this interval is
        # lower than upper bound of previous interval
        # (use <= if want (1, 4) and (4, 6) to be merged)
        if i[0] < prev_i[1]:

            # If so, store the index in the overlap_positions list
            overlap_positions.append(counter)

        # Set the current interval as the prev interval
        # for next iteration and increment counter
        prev_i = i
        counter += 1

    return overlap_positions


# This function accepts the intervals list and
# the list of overlapping positions generated by
# check_for_overlaps function, and returns a new
# list of intervals where overlaps
# have been merged.

def merge_overlaps(sorted_intervals, overlap_positions):

    # List of new merged intervals, and the old
    # ones that need to be removed at the end
    merged_intervals = []
    intervals_to_remove = []

    for p in overlap_positions:

        # For clarity/readability, define the old intervals that overlapped
        old_first_interval = sorted_intervals[p-1]
        old_second_interval = sorted_intervals[p]

        # Create a new merged interval out of the previous overlapping ones
        new_interval = (old_first_interval[0], old_second_interval[1])

        # Add this new interval to the list of merged intervals
        merged_intervals.append(new_interval)

        # Add the old overlapping ones to the list to be removed
        intervals_to_remove.append(old_first_interval)
        intervals_to_remove.append(old_second_interval)

    # Remove the old intervals from original sorted intervals list
    for i in intervals_to_remove:
        if i in sorted_intervals:
            sorted_intervals.remove(i)

    # Add the new, merged intervals back into the intervals list
    sorted_intervals.extend(merged_intervals)

    # Sort the list and return it
    return sorted(sorted_intervals)


# Because there are some cases where merging
# overlapping intervals may result
# in new intervals that still overlap
# (e.g there were 3 or 4 itnervals in the
# original list that all overlapped with
# each other), this function
# will continue to loop through until
# that is no longer the case.

# It accepts a single list of intervals as an argument.

def process_until_all_merged(intervals_list):

    # Sort the intervals list based on first value of each interval
    # (need to to do this for iterative nature of the other fucntions)

    sorted_intervals = sorted(intervals_list)

    # Get any overlapping positions in the list
    overlap_positions = check_for_overlaps(sorted_intervals)

    # If/while there are still overlapping positions, merge them
    while len(overlap_positions) > 0:

        sorted_intervals = merge_overlaps(sorted_intervals, overlap_positions)

        overlap_positions = check_for_overlaps(sorted_intervals)

    return sorted(sorted_intervals)


print(process_until_all_merged(all_cases_at_once))
